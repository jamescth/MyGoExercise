// Step by Step guide to SSH using GO
// http://golang-basic.blogspot.com/2014/06/step-by-step-guide-to-ssh-using-go.html
package ssh

import (
	"bytes"
	"errors"
	"io/ioutil"
	"os/user"
	"time"

	"golang.org/x/crypto/ssh"
)

/*
 http://stackoverflow.com/questions/1346509/automate-scp-file-transfer-using-a-shell-script

 Instead of hardcording passwd in a shell script, use SSH keys, its easier and secure.

 assuming the private key is at ~/.ssh/id_rsa
 to generate a public/private key pair:
	ssh-keygen -t rsa

 The above will generate 2 files, ~/.ssh/id_rsa (private key) and ~/.ssh/id_rsa.pub (public)

 To setup the SSH keys for usage (one time task): Copy the contents of ~/.ssh/id_rsa.pub and
 paste in a new line of ~devops/.ssh/authorized_keys in myserver

 SSH login without passwd
 http://www.linuxproblem.org/art_9.html
*/

/*
	when the client uses a 'rsa key' for authentication.  In this case,
	we might need some more information for which we can create a helper
	function.

	.USER: we will need to know the current user.  Most importantly, the user (
			$whoami) on the local machine.  That user should have ssh access
			to the remote via public-private keys.
	.KEYS: we will need the public rsa key file generated by ssh-keygen, in
			order to ssh.  ssh-keygen will generate rsk public private keys in /user/
*/

func getKeyFile() (key ssh.Signer, err error) {
	usr, _ := user.Current()
	file := usr.HomeDir + "/.ssh/id_rsa"
	buf, err := ioutil.ReadFile(file)
	if err != nil {
		return
	}
	key, err = ssh.ParsePrivateKey(buf)
	if err != nil {
		return
	}
	return
}

type SSH_Config struct {
	Usr    string
	Passwd string
	Host   string
}

func (conn *SSH_Config) Connect() (
	client *ssh.Client, err error) {

	// Do we want to verify Usr & Passwd as well?

	if conn.Host == "" {
		return nil, errors.New("host not found")
	}

	// Step 1. First you need a Client interface that supports all ssh client functions
	//			like supporting subprocesses, port forwarding and tunneled dialing.

	// For getting an instance of ssh client, we need to define ClientConfig.
	// when the client uses 'password authentication' method
	//	config := &ssh.ClientConfig{
	//		User: "james",
	//		Auth: []ssh.AuthMethod{
	//			ssh.Password("abc123"),
	//			},
	//		}

	config := &ssh.ClientConfig{
		User: conn.Usr,
		Auth: []ssh.AuthMethod{
			ssh.Password(conn.Passwd),
		},
	}

	// Step 2. Dial up for a tcp connection to remote

	// ONe fo the API's is Dial() on ssh.  Dial starts a client connection to the given
	// SSH server. It is a convenience function that connects to the given network
	// address, initiates the SSH handshake, and then sets up a Client.  For access to
	// incoming channels and requests, use net.Dial with NewClientConn instead.
	client, err = ssh.Dial("tcp", conn.Host+":22", config)
	if err != nil {
		return nil, err
	}
	return client, nil
}

func (conn *SSH_Config) Run_Session(client *ssh.Client, cmd string, t int) (
	string, error) {
	// Step 3. establish interactive session.

	session, err := client.NewSession()
	if err != nil {
		return "", err
	}
	defer session.Close()

	timeout := time.After(time.Duration(t) * time.Second)
	c := make(chan error)
	defer close(c)

	var b bytes.Buffer
	session.Stdout = &b

	// create a goroutine to run cmd
	go func() {
		c <- session.Run(cmd)
	}()

	// wait for goroutine to finish
	select {
	case <-timeout:
		// wait too long, close the channel and fail it
		return "", errors.New("Timeout")
	case err := <-c:
		if err != nil {
			return "", err
		}

	}
	// fmt.Println(b.String())
	return b.String(), nil

}
